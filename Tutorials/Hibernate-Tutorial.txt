* hibernate.cfg.xml property show_sql=true gives all the sql used for ddl and dml by hibernate at console.
* hibernate.cfg.xml property hbm2ddl.auto propeerty should be set to "update". When its set to "create" each time hibernate hits connects to database it 
  re-creates the entire db, deleteing any previous existing records.
* Hibernate supports by default FetchType.Lazy. Which means if we say session.get(User.class,1) and user has a collection of some child obj than it will only be fetched when required.
At the time of getting the user obj from database only the first levelinfo is returned. This is possible by a proxy objectthat hibernate creates and returns. Though this proxy obj must be associated 
with a session to enable laxy initialization.
Example:- 
Entity
public class UserDetails{

 @Id
 @generatedValue(strategy=GenerationType.Auto)
 private int Number;
 Private List<String> listOfStrings;
 
 gettert and setters
 
} 
session.begintransaction();
user=session.get(UserDEtails.class,2)
user.getListOFStrings();// Line 22
session.close();
Above code if line number 22 is written before session.close than proxy obj fetched the data but if after than it throws lazyinitializationException as user obj is not associated withs ession.
To counter that we can sa @ElementCollection(fetch=FetchType.Eager) on collection member var inside UserDetails class.
This can be verified in tutorail video 12.

*@Entity annotation is sufficient to make an java pojo map to database and if no table is created for that entity hibernate creates all
  database schema on its on to persist the pojo values.
* @Temporal is used to define whether for a date field we want to save date or time using "TemporalType.Date or TemporalType.timestamp or TemporalType.Time".
* @Embedded is used ovefr an pojo that is embedded in another entity.
Example:-
@Entity
public class UserDetails{

 @Id
 @generatedValue(strategy=GenerationType.Auto)
 private int Number;
 @Embedded
 private Address add;
 
 
 gettert and setters
 
}

@Embedable
public class Address{
	its member var and gettert and setters
}

* SessionFatory in hibernate is always singelton to avoid performance load on server.
* Code to get SessionFactory=new Configuration().configure().buildSessionFactory().
* Primary keys are of two types:- Serogate key(Key which has no business value) or natural key(which has business value).
* @NotFound(action=NotFoundAction.Ignore), this annotation is used in cases where there is @ManyToOne relationship and its possible that other object is not yet 
  associated.
  Example:-
  @Entity
  public class UserDetails{
	  private int user_id;
	  @OneToMany(mappedBy="user",cascade=CascadeType.All)
	  Collection<Vehicle> vehList=new ArrayList<>();
	  }

  @Entity
	public class vehicle{
	@ManyToOne
	@NotFoundAction(action=NotFoundAction.Ignore)
	@JoinColumn(name="User_Id")
	private UserDetails user;

	}
HibernateTest.java{

		public static void main(String[] args){
			SessionFactory sessionFactory=new Configuration().configure.buildSessionFactory();
			Session session=sessionFactory.openSession();
			UserDetails user=new UserDetails();
			Vehicle vehicle=new Vehicle();
			userdetails.getVehicle().add(vehicle);
			session.save(user);
			session.save(vehicle);//Line 53
		}
}
In above example even if there is a vehicle which has no user associated with it and we try to get userdetails hibernate will not thrown any exception.

* In above example if we use cascadetype.all inside onetomany mapping then no need to save vehicle. on saving user vehicle gets saved implicitly by hibernate.
   Line #53 not required byt if cascade is not mentioned then need to save child object also explicitly.
* In above example if we use mappedBy, it tells hibernate what UserDetails is mappedBy to Vehicle(user membervariable inside vehicle)
  and @JoinColumn tells hibernate to create a new column inside vehicle to map to userdetails. Without giving mappedBy, hibernate will create a new 
  table for this mapping which is not required.
*For @ManyToMany there shall always be a new Table showing the relationship.
Inheritance in hibernate:-
* Hibernate by default uses "Single Table Strategy" for hibernate.
Example:-
	@Entity
	@Inheritance(startegy=InheritanceType.Single_Table)
	@DiscriminatprColumn(
	name="VEHICLE_TYPE",
	discriminatorType=DiscriminatorType.String
	}
	public class vehicle{
	@Id @GeneratedValue
	String vehicle_name;
	Integer vehicle_id;

	}
	
	@Entity
	@DiscriminatorValue("Bike")
	public class twoWheeler extends vehicle{
	String GearType;

	}
	
	@Entity
	@DiscriminatorValue("Car")
	public class fourWheeler extends vehicle{
	String SteeringType;

	}
	
*Above inheritance structure shall create one singlw table "Vehicle" with default "Single_Table" strategy in hibernate
*If @DiscriminatorType is not given hibetrnate takes the DType as the default name of the column.
*If @DiscriminatorValue is not given hibetrnate takes the class name as the default value.
	VEHICLE_TYPE	VEHICLE_NAME	VEHICLE_ID	GEAR_TYPE	STEERING_TYPE
		VEHICLE	         ABC	       1		
         BIKE	      ThunderBolt	   2	       X	 
		 CAR			Maruti	      3		                                 Y

	
* Hibernate Strategy for "Table Per Class" looks like
Example:-
	@Entity
	@Inheritance(startegy=InheritanceType.Table_Per_Class)
	public class vehicle{
	@Id @GeneratedValue
	String vehicle_name;
	Integer vehicle_id;

	}
	
	@Entity
	public class twoWheeler extends vehicle{
	String GearType;

	}
	
	@Entity
	public class fourWheeler extends vehicle{
	String SteeringType;

	}

	Now we have three tables as:-
	Vehicle Table:-
		VEHICLE_NAME	VEHICLE_ID	
		  Bike1	       		1			
          Bike2	   		    2	       
		  Bike3	      		3	       
	
	TwoWheeler Table:-
		VEHICLE_NAME	VEHICLE_ID	Gear_Type
		  ABC	       		1		    X
        ThunderBolt	   		2	       	Y
		 Maruti	      		3	        Z
		 
	FourWheeler Table:-
		VEHICLE_NAME	VEHICLE_ID	Steering_Type
		  ABC	       		1		    X
        ThunderBolt	   		2	       	Y
		 Maruti	      		3	        Z
 Important point to pick up from above schema is for table_per_class strategy, all the child class have parent table columns as well in addition to there own columns.

*Third and last type of Inheritance Strategy is Inheritance.JOINED. In this all teh vehicles will be dumped in vehicle class and only the the specific column pertaining to child class
is in child table in addition to join column which shows whats the vehicle you are mapping to from parent table.
----Watched videos till 21 from youtube.url:=https://www.youtube.com/watch?v=Zj1mRWfhx_Y&index=19&list=PL4AFF701184976B25--------