*Rest stands for "Representational Stateless Transfer".
*There are two types of webServices:-Rest and Soap.
*Here we mainly talk about REST Webservices.
*Resource URL for RestWebservices can be single level or resource level.
*Example:- a)Http://ip:port/messages  (Collections resource url)
		   b)Http://ip:port/messages/{messageId}/comments/{commentId} (Single resource Url)
*There are four main methods for rest webservices:-
	1)Get
	2)Post
	3)Put
	4)Delete
*GET is used to read the data from applciation.
*PUT is used to update any record in application.
*DELETE is used to delete a record in application..
*POST is used to insert a new record in application.
*Get,Put and Delete are "IDEMPOTENT" as their repeated calls will not mke any change.
*Post is not "IDEMPOTENT".
*Definition of IDENPOTENT:- Its the property of certain operations in computer science that can be applied multiple times without changing the
 initial state of the record or application.
*In GET,PUT and DELETE operatiosn after the first call when multiple repeated calls are made for same resource URL, it will end up in changing 
nothing in the application. So they fit the IDEMPOTENT definitions.
*POST is non-idempotant as repeated calls of it will result into duplicate records in system.
*Restful webservices can be built using JAX-RX(java api for restful webservices).
*One of the common implementation for JAX-RX is Jersey.
(Its like JAX-RX is the guidelines or interfaces and jersey is the implementation or concrete classes)
*Spring @Transactional has two main features:
	1) Propagation:
		* It means hot the transaction will propagate. Types are:
			a) Required: Its default.It means if a trnsaction exist append the new transaction at end of it.
			b) Nested: If a transaction exist then create a savePoitn and then create a nested trnsaction. In case nested transaction throws exception
						rollBack to savePoint.
			c) Never: In case transaction exist then throw exception.
	2) Isolation: This is in line with ACID: Atomicity, Consistency, Isoltaion & Durability.
		* There are three main problems which exist with a concurrent transaction:
			a) Dirty Read: Read uncommited cahnges of other ytransactions.
			b) NonRepetable read: Get different read on re-read of a row if concurrent transaction updates it.
			c) Phantom read: get different rows on a range query as other concurrent transactions adds/remove rows.
		* All above problem can be saved by using Serializable isolation.
Example:
@Transactional(propogation=Propogation.Nested,isolation=Propogation.Serializable)
public void demoMethofTransactions(){

}
			