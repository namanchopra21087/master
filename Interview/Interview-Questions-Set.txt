Backend:
*Spring security using WebSecurityConfigurerAdapter.
*Microservice---->Microservice interaction from distributed env using kafka,SNS,SQS,RabbitMQ.
*Saga design pattern for microservices via:
	*Orchestration
	*Choreography.
*Code monitoring using 
	*Actuator
	*Prometheus
	*Grafana
*Spring cloud config server for centralized application properties which are decoupled from microservices.
*Eureka as Discovery server.
*MongoDb utility w.r.t Sql Db's.
*AOP implementation inside sprinBoot for interceptors.
*Collections:ConcurrentHaspMap,HashMap,Map,List,LinkedList,BlockingQueue.
*Design patterns:
	*Factory design pattern.
	*Singelton design pattern.
*Fault tolerance using Hyterix circuit-breaker.
*JWT.
*

FrontEnd:
*AuthGuard for protecting routes.
*Angular pipe for decorating data from backend.
*Call from angular to backend using HTTPClient.
*Observable vs Promise.
*Inject COmponent B inside Component A using selectors.
*Angular two way data binding.
*Make screen responsive using @media in css.
*How to pass data from one screen to another in angular at runtime.
*How to inject service at root level in angular.
*How to make routes.
*Authentication/Authorization using JWT.
*

AWS:
*SQS.
*SNS.
*Websockets.
*S3.
*Route53
*Data Lake Formation.
*Api Gateway.
*AWS Lambda.
*Application Load Balancer(ALB).
*Classic Load Balancer vs ALB.
*Target Gorups.
*Security Groups.
*Ec2.
*Certification Manager.
*CloudFront.
*Deploy code from bitbucket to Ec2 via Jenkins using Nodes/connector.
*CloudFormation: AWS IAAC(Infrastructure as a code) for provisioning services using configurations.
*Terraform is an open source IAAC for infra provisioning for multiple providers like AWS/Azure/VMWare.
*Aws Polly: Service to convert text to speech.
*Aws Transcribe: Speech To Text.
*Aws TextExtract: Extract text out of images and Pdf.
*Aws Comprehend: Understand emotions out of the text like someone is sad or happy.

Big(O):
*Time complexity of binary search is O(LogN) as it divides and conquer.
*Time complexity of quick sort: O(NLogN).
*Time complexity of recursive function with two calls to same function is O(2^depth).
Example:
a)	int sum(Node node) { 
     if (node == nUll) { 
		return a; 
		} 
	return sum(node . left) + node. value + sum(node.right); 
	} 
	
Time Complexity is: Depth of this function is: LogN as its a binary search= O(2LogN)=O(N)
b) int f(int n) { 

 if (n <= 1) { 
	return 1; 
 } 
	return f(n - 1) + f(n - 1); 
 }
Time Complexity: O(2N)
c) int f(int n) { 

 if (n <= 1) { 
	return 1; 
 } 
	return n+f(n - 1); 
 }
Time COmplexity: O(N).